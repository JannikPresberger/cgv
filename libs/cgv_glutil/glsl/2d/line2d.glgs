#version 430
#extension GL_EXT_geometry_shader4 : enable

#define USE_ROUNDED_CAPS 0

//***** begin interface of fragment2d.glsl ***********************************
uniform float feather_width = 1.0;
//***** end interface of fragment2d.glsl ***********************************

layout(lines) in;
layout(triangle_strip, max_vertices = 4) out;

const vec2 corners[4] = vec2[](
	vec2(0.0, 0.0),
	vec2(1.0, 0.0),
	vec2(0.0, 1.0),
	vec2(1.0, 1.0)
);

uniform mat3 modelview2d_matrix = mat3(1.0);

uniform ivec2 resolution;
uniform float width = 1.0;

in vec4 color_gs[];

#if USE_ROUNDED_CAPS == 0
out vec4 color_fs;
#else
out flat vec4 color0_fs;
out flat vec4 color1_fs;
#endif
out flat vec2 size_fs;
out vec2 tex_coord_fs;
out vec2 pix_coord_fs;

vec2 ortho2d(vec2 v) {
	return vec2(v.y, -v.x);
}

vec4 world_to_window_space(vec2 p) {
	// apply modelview transformation
	vec2 pos = (modelview2d_matrix * vec3(p, 1.0)).xy;

	// transform to window space
	pos = (2.0*pos) / resolution;
	return vec4(pos - 1.0, 0.0, 1.0);
}

void main() {
	
	vec4 start = gl_in[0].gl_Position;
	vec4 end = gl_in[1].gl_Position;

	vec2 delta = end.xy - start.xy;
	float len = length(delta);

	vec2 u_dir = delta / len;
	vec2 v_dir = ortho2d(u_dir.xy);

	float final_width = width + feather_width;
	size_fs = vec2(len + 2.0 * feather_width, final_width);

	u_dir *= feather_width;
	v_dir *= 0.5*final_width;

#if USE_ROUNDED_CAPS == 0
	color_fs = color_gs[0];
	tex_coord_fs = corners[0];
	pix_coord_fs = size_fs*corners[0] - 0.5*size_fs;
	gl_Position = world_to_window_space(start.xy - u_dir + v_dir);
	EmitVertex();
	color_fs = color_gs[1];
	tex_coord_fs = corners[1];
	pix_coord_fs = size_fs*corners[1] - 0.5*size_fs;
	gl_Position = world_to_window_space(end.xy + u_dir + v_dir);
	EmitVertex();

	color_fs = color_gs[0];
	tex_coord_fs = corners[2];
	pix_coord_fs = size_fs*corners[2] - 0.5*size_fs;
	gl_Position = world_to_window_space(start.xy - u_dir - v_dir);
	EmitVertex();
	color_fs = color_gs[1];
	tex_coord_fs = corners[3];
	pix_coord_fs = size_fs*corners[3] - 0.5*size_fs;
	gl_Position = world_to_window_space(end.xy + u_dir - v_dir);;
	EmitVertex();
#else
	color0_fs = color_gs[0];
	color1_fs = color_gs[1];

	start.xy -= u_dir;
	end.xy += u_dir;

	tex_coord_fs = corners[2] - vec2(0.5, 0.0);
	gl_Position = to_window_space(start.xy - v_dir);
	EmitVertex();
	tex_coord_fs = corners[0] - vec2(0.5, 0.0);
	gl_Position = to_window_space(start.xy + v_dir);
	EmitVertex();

	tex_coord_fs = corners[3] * vec2(length_fs+0.5, 1.0);
	gl_Position = to_window_space(end.xy - v_dir);
	EmitVertex();
	tex_coord_fs = corners[1] * vec2(length_fs+0.5, 1.0);
	gl_Position = to_window_space(end.xy + v_dir);;
	EmitVertex();
#endif
}
