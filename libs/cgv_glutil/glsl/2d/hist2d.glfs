#version 430

//***** begin interface of shape2d.glsl ***********************************
uniform ivec2 resolution;

uniform vec4 fill_color;
uniform vec4 border_color = vec4(1.0);
uniform float border_width = 0.0;

float get_feather_width();
vec2 get_shape_size();
vec4 get_active_color(vec4 color);
vec4 transform_world_to_window_space(vec2 p);
//***** end interface of shape2d.glsl ***********************************

//***** begin interface of fragment2d.glfs ***********************************
void finish_sdf_fragment2d(in float signed_distance, in vec4 color);
void finish_sdf_fragment2d(in float signed_distance, in vec4 color, in vec2 texcoords);
void finish_fragment2d(in vec4 color);
void finish_fragment2d(in vec4 color, in vec2 texcoords);
//***** end interface of fragment2d.glfs ***********************************

uniform layout(binding = 1) sampler1D hist_tex;

uniform uint max_value = 1u;
uniform float nearest_linear_mix = 1.0;

uniform float A;

flat in vec2 size;
in vec2 pix_coord;
in vec2 tex_coord;

float texture_nearest(sampler1D tex, float coord) {
	int tex_size = textureSize(tex, 0);
	int u = int(coord * tex_size);

	return texelFetch(tex, u, 0).r;
}

float texture_linear(sampler1D tex, float coord) {
	return texture(tex, coord).r;
}

// smooth filtering from https://www.shadertoy.com/view/XsfGDn
float texture_smooth(in sampler1D tex, in float coord) {
	float tex_size = textureSize(tex, 0);
	float u = coord * tex_size + 0.5;

	float iu = floor(u);
	float fu = fract(u);

	u = iu + fu*fu*(3.0-2.0*fu); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);
	u = (u - 0.5)/tex_size;

	return textureLod(tex, u, 0).r;
}

// cubic interpolation function
float texture_cubic(in sampler1D tex, in float coord) {
	// shift the coordinate from [0,1] to [-0.5, tex_size-0.5]
	float tex_size = textureSize(tex, 0);
	float coord_grid = coord * tex_size - 0.5;
	float index = floor(coord_grid);
	float fraction = coord_grid - index;
	float one_frac = 1.0 - fraction;

	float w0 = 1.0/6.0 * one_frac*one_frac*one_frac;
	float w1 = 2.0/3.0 - 0.5 * fraction*fraction*(2.0-fraction);
	float w2 = 2.0/3.0 - 0.5 * one_frac*one_frac*(2.0-one_frac);
	float w3 = 1.0/6.0 * fraction*fraction*fraction;

	float g0 = w0 + w1;
	float g1 = w2 + w3;
	float mult = 1.0 / tex_size;
	float h0 = mult * ((w1 / g0) - 0.5 + index);
	float h1 = mult * ((w3 / g1) + 1.5 + index);

	// fetch the two linear interpolations
	float tex000 = textureLod(tex, h0, 0).r;
	float tex100 = textureLod(tex, h1, 0).r;
	return mix(tex100, tex000, g0.x);
}


float sd_line(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p-a, ba = b-a;
    float h = dot(pa,ba)/dot(ba,ba);
    return length( pa - ba*h );
}

void main() {
	
	vec4 final_color = vec4(0.0);


	//final_color = vec4(1.0, 0.0, 0.0, 0.5);
	//final_color = vec4(texture(hist_tex, tex_coord.x).r > 0.0 ? 1.0 : 0.0, 0.0, 0.0, 1.0);
	//finish_fragment2d(final_color);
	

	

	/*float height_nearest = texture_nearest(hist_tex, tex_coord.x) / float(max_value);
	float height_linear = texture(hist_tex, tex_coord.x).r / float(max_value);
	float height_smooth = texture_smooth(hist_tex, tex_coord.x) / float(max_value);
	float height_cubic = texture_cubic(hist_tex, tex_coord.x) / float(max_value);

	float a = height_nearest;
	float b = height_linear;
	float t = nearest_linear_mix;
	if(t > 0.666667) {
		t -= 0.666667;
		a = height_smooth;
		b = height_cubic;
	} else if(t > 0.333333) {
		t -= 0.333333;
		a = height_linear;
		b = height_smooth;
	}

	t *= 3.0;
	t = clamp(t, 0.0, 1.0);

	float height = mix(a, b, t);*/

	float off = 1.0 / size.x;
	float y_step = 1.0 / size.y;

#define TEX_FUNC texture_linear

	float height = TEX_FUNC(hist_tex, tex_coord.x) / float(max_value);
	float height_prev = TEX_FUNC(hist_tex, tex_coord.x - off) / float(max_value);
	float height_next = TEX_FUNC(hist_tex, tex_coord.x + off) / float(max_value);
	
	float y = tex_coord.y;

	float dist = sd_line(
		vec2(1.0, size.y*y),
		vec2(0.0, size.y*height_prev),
		vec2(2.0, size.y*height_next)
	);

	//float mid = 0.5*(height_prev + height_next);
	//if(y < mid)
	//	dist = -dist;

	final_color = fill_color;

	if(y <= height) {
		dist = - dist;
		final_color = fill_color;
		//float slope = 10.0*(height_next - height_prev);
		//final_color.rgb = slope < 0.0 ? vec3(0.0, 0.0, -slope) : vec3(slope, 0.0, 0.0);
	} else {
		float dist = sd_line(
			vec2(1.0, size.y*y),
			vec2(0.0, size.y*height_prev),
			vec2(2.0, size.y*height_next)
		);

		final_color = fill_color;

		float feather_alpha = 1.0 - clamp((dist - 1.0) / 1.0, 0.0, 1.0);

		final_color.rgb = vec3(dist*10.0*nearest_linear_mix, 0.0, 0.0);
		//final_color.a *= feather_alpha;

		//float slope = height_next - height_prev;
		//final_color.rgb = slope < 0.0 ? vec3(0.0, 0.0, -slope) : vec3(slope, 0.0, 0.0);

		/*if(y <= height_next) {
			float dist = tex_coord.y - height;
			dist /= height_next - height;
			dist = 1.0 - clamp(dist, 0.0, 1.0);
			final_color = fill_color;
			final_color.a = dist;
		}
		if(y <= height_prev) {
			float dist = tex_coord.y - height;
			dist /= height_prev - height;
			dist = 1.0 - clamp(dist, 0.0, 1.0);
			final_color = fill_color;
			final_color.a = dist;
		}*/
	}

	//if(height_prev < height && height_next < height || height_prev > height && height_next > height)
		//dist = size.y * (y - height);


	/*float border = 0.0f;

	if(border_width > 0.1)
		border = border_width / resolution.y;

	if(tex_coord.y <= height + border) {
		final_color = border_color;
		
		if(tex_coord.y <= height)
			final_color = fill_color;
	}*/

	//final_color = vec4(1.0, 0.0, 0.0, 0.5);
	//final_color = vec4(texture(hist_tex, tex_coord.x).r > 0.0 ? 1.0 : 0.0, 0.0, 0.0, 1.0);
	//finish_fragment2d(final_color);
	finish_sdf_fragment2d(dist, final_color);

	// Smoothstep
	/*int size = textureSize(tex, 0);
	float texel_size = 1.0 / float(size);

	float v0 = texture(tex, tex_coord.x).r / float(max_value);
	float v1 = texture(tex, tex_coord.x + texel_size).r / float(max_value);

	float u = tex_coord.x * size;
	float u_int = 0.0;
	float u_frac = modf(u, u_int);

	float t = smoothstep(0.0, 1.0, u_frac);
	float height = mix(v0, v1, t);

	frag_color = vec4(vec3(tex_coord.y > height ? 0.0 : 1.0), 1.0);*/

	// Pseudo-Antialiased
		/*
		float height = texture(tex, tex_coord.x).r / float(max_value);

	//if(tex_coord.y <= height) {
		frag_color = color;
		frag_color.a = 1.0;

		float pixel_size = 1.0 / float(resolution.y);

		float delta = fwidth(height);

		float alpha1 = 1.0 - smoothstep(height - delta, height, tex_coord.y);
		float alpha2 = 1.0 - smoothstep(height - pixel_size, height, tex_coord.y);

		frag_color.rgb *= min(alpha1, alpha2);

		/*if(border_width_in_pixel > 0u) {
			
			float border = float(border_width_in_pixel) * pixel_size;

			if(tex_coord.y >= height - border)
				frag_color = border_color;
		}*
	//} else {
	//	frag_color = vec4(0.0);
	//}

	if(apply_gamma)
		frag_color.rgb = clamp(pow(frag_color.rgb, vec3(2.2)), 0.0, 0.9999999);

	if(!use_blending)
		frag_color.a = 1.0;*/
}
