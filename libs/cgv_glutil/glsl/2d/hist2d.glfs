#version 430

//***** begin interface of shape2d.glsl ***********************************
uniform ivec2 resolution;

uniform vec4 fill_color;
uniform vec4 border_color = vec4(1.0);
uniform float border_width = 0.0;

float get_feather_width();
vec2 get_shape_size();
vec4 get_active_color(vec4 color);
vec4 transform_world_to_window_space(vec2 p);
//***** end interface of shape2d.glsl ***********************************

//***** begin interface of fragment2d.glfs ***********************************
void finish_sdf_fragment2d(in float signed_distance, in vec4 color);
void finish_sdf_fragment2d(in float signed_distance, in vec4 color, in vec2 texcoords);
void finish_fragment2d(in vec4 color);
void finish_fragment2d(in vec4 color, in vec2 texcoords);
//***** end interface of fragment2d.glfs ***********************************

uniform layout(binding = 1) sampler1D hist_tex;

uniform uint max_value = 1u;
uniform float nearest_linear_mix = 1.0;

uniform float A;

flat in vec2 size;
in vec2 pix_coord;
in vec2 tex_coord;

float texture_nearest(sampler1D tex, float coord) {
	int tex_size = textureSize(tex, 0);
	int u = int(coord * tex_size);

	return texelFetch(tex, u, 0).r;
}

float texture_linear(sampler1D tex, float coord) {
	return texture(tex, coord).r;
}

// smooth filtering from https://www.shadertoy.com/view/XsfGDn
float texture_smooth(in sampler1D tex, in float coord) {
	float tex_size = textureSize(tex, 0);
	float u = coord * tex_size + 0.5;

	float iu = floor(u);
	float fu = fract(u);

	u = iu + fu*fu*(3.0-2.0*fu); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);
	u = (u - 0.5)/tex_size;

	return textureLod(tex, u, 0).r;
}

// cubic interpolation function
float texture_cubic(in sampler1D tex, in float coord) {
	// shift the coordinate from [0,1] to [-0.5, tex_size-0.5]
	float tex_size = textureSize(tex, 0);
	float coord_grid = coord * tex_size - 0.5;
	float index = floor(coord_grid);
	float fraction = coord_grid - index;
	float one_frac = 1.0 - fraction;

	float w0 = 1.0/6.0 * one_frac*one_frac*one_frac;
	float w1 = 2.0/3.0 - 0.5 * fraction*fraction*(2.0-fraction);
	float w2 = 2.0/3.0 - 0.5 * one_frac*one_frac*(2.0-one_frac);
	float w3 = 1.0/6.0 * fraction*fraction*fraction;

	float g0 = w0 + w1;
	float g1 = w2 + w3;
	float mult = 1.0 / tex_size;
	float h0 = mult * ((w1 / g0) - 0.5 + index);
	float h1 = mult * ((w3 / g1) + 1.5 + index);

	// fetch the two linear interpolations
	float tex000 = textureLod(tex, h0, 0).r;
	float tex100 = textureLod(tex, h1, 0).r;
	return mix(tex100, tex000, g0.x);
}


float sd_line(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p-a, ba = b-a;
    float h = dot(pa,ba)/dot(ba,ba);
    return length( pa - ba*h );
}

void main() {
	
	vec4 final_color = fill_color;
	float off = 1.0 / size.x;

#define TEX_FUNC texture_linear

	float height = TEX_FUNC(hist_tex, tex_coord.x) / float(max_value);
	float height_prev = TEX_FUNC(hist_tex, tex_coord.x - off) / float(max_value);
	float height_next = TEX_FUNC(hist_tex, tex_coord.x + off) / float(max_value);

	float y = tex_coord.y;
	


	float line_dist = sd_line(
		vec2(1.0, size.y*y),
		vec2(0.0, size.y*height_prev),
		vec2(2.0, size.y*height_next)
	);


	if(y < height)
		line_dist = -line_dist;





	float height_dist = size.y * (y - height);
	float slope = size.y*(height_next - height_prev);


	float s0 = size.y*(height - height_prev);
	float s1 = size.y*(height_next - height);

	float dist = abs(slope) > 1.0 ? line_dist : height_dist;

	if(sign(s0) != sign(s1))
		dist = height_dist;
	

	//float dist_prev = y - height_prev;
	//float dist_next = y - height_next;
	//
	//float dd = dist;
	//if(dist_prev < dist) { dd = nearest_linear_mix; final_color.rgb = vec3(1.0, 0.0, 0.0); }
	//if(dist_next < dist) { dd = nearest_linear_mix; final_color.rgb = vec3(0.0, 0.0, 1.0); }
	//
	//dd *= size.y;

	//final_color.rgb = slope < 0.0 ? vec3(0.0, 0.0, -slope*100.0*nearest_linear_mix) : vec3(slope*100.0*nearest_linear_mix, 0.0, 0.0);
	//final_color.rgb = abs(slope) > 1.0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);
	//final_color.a = 1.0;


	finish_sdf_fragment2d(dist, final_color);
}
