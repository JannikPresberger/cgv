#version 430

//***** begin interface of fragment2d.glsl ***********************************
uniform float border_radius = 0.0;
uniform float feather_width = 1.0;
uniform float feather_origin = 0.5;
//***** end interface of fragment2d.glsl ***********************************

const vec2 corners[4] = vec2[](
	vec2(0.0, 0.0),
	vec2(1.0, 0.0),
	vec2(0.0, 1.0),
	vec2(1.0, 1.0)
);

const vec2 direction_factors[4] = vec2[](
	vec2(-1.0, +1.0),
	vec2(+1.0, +1.0),
	vec2(-1.0, -1.0),
	vec2(+1.0, -1.0)
);

uniform mat3 modelview2d_matrix = mat3(1.0);

uniform ivec2 resolution;
uniform ivec2 position_a;
uniform ivec2 position_b;
uniform float stem_width;
uniform float head_width;
uniform float head_length;
uniform bool head_length_is_relative;

out vec2 pix_coord;
out vec2 tex_coord;
out flat vec2 pos_a;
out flat vec2 pos_b;
out vec4 color_fs;
out flat float hl;

vec2 ortho2d(vec2 v) {
	return vec2(v.y, -v.x);
}

vec4 world_to_window_space(vec2 p) {
	// apply modelview transformation
	vec2 pos = (modelview2d_matrix * vec3(p, 1.0)).xy;

	// transform to window space
	pos = (2.0*pos) / resolution;
	return vec4(pos - 1.0, 0.0, 1.0);
}

void main() {
	int id = gl_VertexID;
	vec2 corner = corners[id];

	float width = max(stem_width, head_width);
	
	vec2 delta = position_b - position_a;
	float len = length(delta);

	hl = head_length_is_relative ? head_length * len : head_length;

	vec2 u_dir = delta / len;
	vec2 v_dir = ortho2d(u_dir.xy);

	float final_width = width + 2.0*feather_origin*feather_width;

	v_dir *= 0.5*final_width;

	pos_a = position_a + border_radius*u_dir; 
	pos_b = position_b - border_radius*u_dir;

	u_dir *= feather_origin*feather_width;

	pos_a -= u_dir;
	pos_b += u_dir;

	vec2 position = (id&1) == 0 ? position_a : position_b;

	vec2 direction_factor = direction_factors[id];
	vec2 corner_position = position + direction_factor.x*u_dir + direction_factor.y*v_dir;

	tex_coord = corner;
	pix_coord = corner_position;
	gl_Position = world_to_window_space(corner_position);
}
