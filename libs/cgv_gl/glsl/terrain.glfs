#version 330 core

in vec4 color_fs;
in vec2 uv_fs;
in vec3 normal_eye;
in vec3 position_eye;
in float normalized_height_fs;

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

//***** begin interface of fragment.glfs ***********************************
uniform float gamma = 2.2;
void finish_fragment(vec4 color);
//***** end interface of fragment.glfs ***********************************

//***** begin interface of surface.glsl ***********************************
struct Material {
    int brdf_type;
    vec3 diffuse_reflectance;
    float roughness;
    float metalness;
    float ambient_occlusion;
    vec3 emission;
    float transparency;
    vec2 propagation_slow_down;
    float roughness_anisotropy;
    float roughness_orientation;
    vec3 specular_reflectance;
};

Material get_material();
vec4 compute_reflected_radiance(in Material M, vec3 position_eye, vec3 normal_eye);
vec4 compute_reflected_appearance(vec3 position_eye, vec3 normal_eye, vec4 color, int side);
vec4 compute_reflected_appearance_texture(vec3 position_eye, vec3 normal_eye, vec2 texcoords, vec4 color, int side);
//***** end interface of surface.glsl ***********************************

//***** begin interface of side.glsl ***********************************
bool keep_this_side(in vec3 position, in vec3 normal, out int side);
void update_material_color_and_transparency(inout vec3 mat_color, inout float transparency, in int side, in vec4 color);
void update_normal(inout vec3 normal, in int side);
//***** end interface of side.glsl ***********************************

uniform float grassLevel;
uniform float rockLevel;
uniform float blur;

uniform sampler2D grassTexture;
uniform sampler2D dirtTexture;
uniform sampler2D rockTexture;

//vec3 getSurfaceColor(float height) {
//    // TODO make color dependent on normal
//    const float grassDamper = 0.75F;
//    const float dirtDamper = 0.9F;
//    if (height < grassLevel-blur) {
//        vec3 grassColor = texture(grassTexture, uv_fs).rgb * grassDamper;
//        return grassColor;
//    } else if (height < grassLevel+blur) {
//        vec3 grassColor = texture(grassTexture, uv_fs).rgb * grassDamper;
//        vec3 dirtColor = texture(dirtTexture, uv_fs).rgb * dirtDamper;
//        float t = (height-(grassLevel-blur)) / (2.0F*blur);
//        return mix(grassColor, dirtColor, t);
//    } else if (height < rockLevel-blur){
//        vec3 dirtColor = texture(dirtTexture, uv_fs).rgb * dirtDamper;
//        return dirtColor;
//    } else if (height < rockLevel+blur) {
//        vec3 dirtColor = texture(dirtTexture, uv_fs).rgb * dirtDamper;
//        vec3 rockColor = texture(rockTexture, uv_fs).rgb;
//        float t = (height-(rockLevel-blur)) / (2.0F*blur);
//        return mix(dirtColor, rockColor, t);
//    } else {
//        vec3 rockColor = texture(rockTexture, uv_fs).rgb;
//        return rockColor;
//    }
//}

void main() {
    vec3 normal = normalize(normal_eye);
    int side;
    if (!keep_this_side(position_eye, normal, side)) {
        discard;
    }
    finish_fragment(compute_reflected_appearance(position_eye, normal, color_fs, side));
}
