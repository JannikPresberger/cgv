#version 330 core

uniform float blend_width_in_pixel = 1.0;
uniform float halo_width_in_pixel = 0.0;
uniform float percentual_halo_width = 0.0;

//***** begin interface of splat.glsl ***********************************
void prepare_splat(
	in float reference_point_radius, in float pixel_extent,
	in float blend_width_in_pixel, in float halo_width_in_pixel, in float percentual_halo_width,
	out float percentual_core_size, out float percentual_point_size,
	out float percentual_blend_width, out float percentual_splat_size);
//***** end interface of surface.glsl ***********************************

//***** begin interface of sphere_lib.glgs ***********************************
struct sphere_parameter_space
{
	vec3  m_tilde;
	vec3  x_tilde;
	vec3  y_tilde;
	vec3  e_tilde;
	float inv_e_vs;
	vec3  inv_T_square_e_c_vs;
	vec2  e_zw_clip_vs;
};

void generate_sphere_cover_splat(in vec4 sphere, in sphere_parameter_space sps, in mat4 MV, in mat4 MVP, in mat3 NM, in float splat_size);
//***** end interface of sphere_lib.glgs ***********************************

uniform float pixel_extent_per_depth;

in mat3 NM[];
in mat4 MV[];
in mat4 MVP[];

in sphere_parameter_space sps[];
in vec4  color_gs[];

out vec4  color_fs;

out float percentual_blend_width;
out float percentual_point_size;
out float percentual_core_size;
out float percentual_splat_size;

void main()
{

	color_fs		     = color_gs[0];
	// compute depth of sphere center
	float depth = abs((MV[0] * vec4(gl_in[0].gl_Position.xyz, 1.0)).z);
	// compute extent of a pixel at sphere center depth 
	float pixel_extent = pixel_extent_per_depth * depth;
	// compute splat parameters for fragment shader
	prepare_splat(gl_in[0].gl_Position.w, pixel_extent,
		blend_width_in_pixel, halo_width_in_pixel, percentual_halo_width,
		percentual_core_size, percentual_point_size,
		percentual_blend_width, percentual_splat_size);

	generate_sphere_cover_splat(gl_in[0].gl_Position, sps[0], MV[0], MVP[0], NM[0], percentual_splat_size);
}