<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cgv: cgv::base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cgv
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacecgv_1_1base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cgv::base Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>the base namespace holds the base hierarchy, support for plugin registration and signals  
<a href="namespacecgv_1_1base.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1action.html">action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1argument__handler.html">argument_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for objects that process unknown command line arguments  <a href="structcgv_1_1base_1_1argument__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base.html">base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base__generator.html">base_generator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1base__method__action.html">base_method_action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1command__info.html">command_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure to store an analized command  <a href="structcgv_1_1base_1_1command__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1config__file__driver.html">config_file_driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for a config file driver that handles permanent registration and gui config files.  <a href="structcgv_1_1base_1_1config__file__driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1config__file__observer.html">config_file_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface for observers of config files.  <a href="structcgv_1_1base_1_1config__file__observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1console.html">console</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1driver.html">driver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces that add several listeners and objects.  <a href="structcgv_1_1base_1_1driver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory.html">factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface for a factory that allows to create objects derived from <a class="el" href="classcgv_1_1base_1_1base.html">cgv::base::base</a>  <a href="structcgv_1_1base_1_1factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__impl.html">factory_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory for objects of type T using the standard constructor  <a href="structcgv_1_1base_1_1factory__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__impl__1.html">factory_impl_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory for objects of type T using a constructor with one argument of type CA  <a href="structcgv_1_1base_1_1factory__impl__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__impl__2.html">factory_impl_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of factory for objects of type T using a constructor with two arguments of types CA1 and CA2  <a href="structcgv_1_1base_1_1factory__impl__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__registration.html">factory_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a factory of the given class type  <a href="structcgv_1_1base_1_1factory__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__registration__1.html">factory_registration_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a factory of the given class type that uses a constructor with one argument of type CA  <a href="structcgv_1_1base_1_1factory__registration__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1factory__registration__2.html">factory_registration_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a factory of the given class type that uses a constructor with one argument of type CA  <a href="structcgv_1_1base_1_1factory__registration__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1find__action.html">find_action</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple action implementation that adds nodes implementing X to a results vector  <a href="classcgv_1_1base_1_1find__action.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1group.html">group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1matched__method__action.html">matched_method_action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1method__action.html">method_action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1method__action__2.html">method_action_2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1named.html">named</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1node.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1object__constructor.html">object_constructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract base class of helpers to perform delayed registration and creation of objects in case that the registration is currently disabled  <a href="structcgv_1_1base_1_1object__constructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1object__registration.html">object_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register an object of the given class type  <a href="structcgv_1_1base_1_1object__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1object__registration__1.html">object_registration_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register an object of the given class type with one constructor argument  <a href="structcgv_1_1base_1_1object__registration__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1object__registration__2.html">object_registration_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register an object of the given class type with two constructor arguments  <a href="structcgv_1_1base_1_1object__registration__2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1registration__listener.html">registration_listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces that allows to listen to registration events.  <a href="structcgv_1_1base_1_1registration__listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1registration__order__definition.html">registration_order_definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class whose constructor calls the <code><a class="el" href="namespacecgv_1_1base.html#ada908977e738c6da6230a698912bebc4" title="specify a partial order of objects for registration">define_registration_order()</a></code> function  <a href="structcgv_1_1base_1_1registration__order__definition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1resource__file__info.html">resource_file_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">information registered with each resource file  <a href="structcgv_1_1base_1_1resource__file__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1resource__file__registration.html">resource_file_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a resource file  <a href="structcgv_1_1base_1_1resource__file__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1resource__string__registration.html">resource_string_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class to register a resource string  <a href="structcgv_1_1base_1_1resource__string__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1server.html">server</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces that add provides very basic functionality.  <a href="structcgv_1_1base_1_1server.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1single__method__action.html">single_method_action</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1single__method__action__2.html">single_method_action_2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1test.html">test</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure used to register a test function  <a href="classcgv_1_1base_1_1test.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcgv_1_1base_1_1test__registration.html">test_registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">declare an instance of <a class="el" href="structcgv_1_1base_1_1test__registration.html" title="declare an instance of test_registration as static variable in order to register a test function in a...">test_registration</a> as static variable in order to register a test function in a test plugin  <a href="structcgv_1_1base_1_1test__registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__callback__handler.html">traverse_callback_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface of a handler for traverse callbacks  <a href="classcgv_1_1base_1_1traverse__callback__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverse__policy.html">traverse_policy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">nodes should inherit from this policy class to allow selective tree traversals  <a href="classcgv_1_1base_1_1traverse__policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcgv_1_1base_1_1traverser.html">traverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class used to traverse a tree structure  <a href="classcgv_1_1base_1_1traverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adf49b672c57e35e9ac4a9d6980f50562"><td class="memItemLeft" align="right" valign="top"><a id="adf49b672c57e35e9ac4a9d6980f50562"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1base.html">base</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a></td></tr>
<tr class="memdesc:adf49b672c57e35e9ac4a9d6980f50562"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to base <br /></td></tr>
<tr class="separator:adf49b672c57e35e9ac4a9d6980f50562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483e13cc8a05eab04f07848e4e2ab4c8"><td class="memItemLeft" align="right" valign="top"><a id="a483e13cc8a05eab04f07848e4e2ab4c8"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">cgv::data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1console.html">console</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a483e13cc8a05eab04f07848e4e2ab4c8">console_ptr</a></td></tr>
<tr class="memdesc:a483e13cc8a05eab04f07848e4e2ab4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to console <br /></td></tr>
<tr class="separator:a483e13cc8a05eab04f07848e4e2ab4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea49074b205caba6f6a72feb0ad8879b"><td class="memItemLeft" align="right" valign="top"><a id="aea49074b205caba6f6a72feb0ad8879b"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1group.html">group</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aea49074b205caba6f6a72feb0ad8879b">group_ptr</a></td></tr>
<tr class="memdesc:aea49074b205caba6f6a72feb0ad8879b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:aea49074b205caba6f6a72feb0ad8879b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ed99892cc76b1f339b9a0693bb0e1f"><td class="memItemLeft" align="right" valign="top"><a id="a41ed99892cc76b1f339b9a0693bb0e1f"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1named.html">named</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a41ed99892cc76b1f339b9a0693bb0e1f">named_ptr</a></td></tr>
<tr class="memdesc:a41ed99892cc76b1f339b9a0693bb0e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:a41ed99892cc76b1f339b9a0693bb0e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af525d4a6a81e7899a679e179ccbbab7b"><td class="memItemLeft" align="right" valign="top"><a id="af525d4a6a81e7899a679e179ccbbab7b"></a>
typedef <a class="el" href="classcgv_1_1data_1_1ref__ptr.html">data::ref_ptr</a>&lt; <a class="el" href="classcgv_1_1base_1_1node.html">node</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#af525d4a6a81e7899a679e179ccbbab7b">node_ptr</a></td></tr>
<tr class="memdesc:af525d4a6a81e7899a679e179ccbbab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ref counted pointer to a node <br /></td></tr>
<tr class="separator:af525d4a6a81e7899a679e179ccbbab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a746925f26d076c26742b2dc558cbae36"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36">TraversePolicy</a> { , <br />
&#160;&#160;<a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a4dd87fc30d8a2e369fe315eb9ccde557">TP_ONLY_FOCUS</a>, 
<a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a69ee76315433dc44f8bfa441afefa249">TP_FIRST_FOCUS</a>, 
<a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a169ba2fab3a13ea551eb8d8800e459bb">TP_AUTO_FOCUS</a>, 
<a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a7b2b5c718b50e4241491dcb951599a8b">TP_STOP_ON_SUCCESS</a> = 8, 
<br />
&#160;&#160;<a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36a33806b12ea827401e0a110036ddbeabe">TP_STOP_ON_FAILURE</a> = 16
<br />
 }</td></tr>
<tr class="memdesc:a746925f26d076c26742b2dc558cbae36"><td class="mdescLeft">&#160;</td><td class="mdescRight">different traversal policies  <a href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36">More...</a><br /></td></tr>
<tr class="separator:a746925f26d076c26742b2dc558cbae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e996b7f5a3a74779d9cee38497ba673"><td class="memItemLeft" align="right" valign="top"><a id="a2e996b7f5a3a74779d9cee38497ba673"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a2e996b7f5a3a74779d9cee38497ba673">TraverseStrategy</a> </td></tr>
<tr class="memdesc:a2e996b7f5a3a74779d9cee38497ba673"><td class="mdescLeft">&#160;</td><td class="mdescRight">not yet implemented <br /></td></tr>
<tr class="separator:a2e996b7f5a3a74779d9cee38497ba673"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a33c3982af255622d93a69be50f3b2e06"><td class="memTemplParams" colspan="2"><a id="a33c3982af255622d93a69be50f3b2e06"></a>
template&lt;typename T1 , class X , typename R &gt; </td></tr>
<tr class="memitem:a33c3982af255622d93a69be50f3b2e06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1base_1_1single__method__action.html">single_method_action</a>&lt; X, R, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a33c3982af255622d93a69be50f3b2e06">make_action</a> (T1 _v1, R(X::*_on_begin)(T1), bool _default_result_begin=false, bool _default_result_end=false)</td></tr>
<tr class="memdesc:a33c3982af255622d93a69be50f3b2e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to construct an action from a signature and one method that is called when a node is entered <br /></td></tr>
<tr class="separator:a33c3982af255622d93a69be50f3b2e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c60002b6fe7ac3ea746b589f43d75af"><td class="memTemplParams" colspan="2"><a id="a4c60002b6fe7ac3ea746b589f43d75af"></a>
template&lt;typename T1 , class X , typename R1 , typename R2 &gt; </td></tr>
<tr class="memitem:a4c60002b6fe7ac3ea746b589f43d75af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1base_1_1matched__method__action.html">matched_method_action</a>&lt; X, R1, R2, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a4c60002b6fe7ac3ea746b589f43d75af">make_action</a> (T1 _v1, R1(X::*_on_begin)(T1), R2(X::*_on_end)(T1), bool _default_result_begin=false, bool _default_result_end=false)</td></tr>
<tr class="memdesc:a4c60002b6fe7ac3ea746b589f43d75af"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to construct an action from a signature and two methods that are called when a node is entered and when it is left again <br /></td></tr>
<tr class="separator:a4c60002b6fe7ac3ea746b589f43d75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9586bffe7837806145302b7f933ea8"><td class="memTemplParams" colspan="2"><a id="a4d9586bffe7837806145302b7f933ea8"></a>
template&lt;typename T1 , typename T2 , class X , typename R &gt; </td></tr>
<tr class="memitem:a4d9586bffe7837806145302b7f933ea8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcgv_1_1base_1_1single__method__action__2.html">single_method_action_2</a>&lt; X, R, T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a4d9586bffe7837806145302b7f933ea8">make_action_2</a> (T1 _v1, T2 _v2, R(X::*_on_begin)(T1, T2), bool _default_result_begin=false, bool _default_result_end=false)</td></tr>
<tr class="memdesc:a4d9586bffe7837806145302b7f933ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function to construct an action from a signature and one method that is called when a node is entered <br /></td></tr>
<tr class="separator:a4d9586bffe7837806145302b7f933ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56137cd8bf24c23f7f6ef15a417bbdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ac56137cd8bf24c23f7f6ef15a417bbdd">attach</a> (<a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> slot_object, <a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> attachment_object, void *user_data)</td></tr>
<tr class="memdesc:ac56137cd8bf24c23f7f6ef15a417bbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to attach an object to an object of type <a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a>.  <a href="namespacecgv_1_1base.html#ac56137cd8bf24c23f7f6ef15a417bbdd">More...</a><br /></td></tr>
<tr class="separator:ac56137cd8bf24c23f7f6ef15a417bbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f23268db7fec467dfd98ab36094f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a1e3f23268db7fec467dfd98ab36094f5">get_attachment</a> (<a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> slot_object)</td></tr>
<tr class="memdesc:a1e3f23268db7fec467dfd98ab36094f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">query the attachment of an <a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a> object.  <a href="namespacecgv_1_1base.html#a1e3f23268db7fec467dfd98ab36094f5">More...</a><br /></td></tr>
<tr class="separator:a1e3f23268db7fec467dfd98ab36094f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec69e775624f1ca64e001ff8b1254344"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aec69e775624f1ca64e001ff8b1254344">get_attachment_data</a> (<a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> slot_object)</td></tr>
<tr class="memdesc:aec69e775624f1ca64e001ff8b1254344"><td class="mdescLeft">&#160;</td><td class="mdescRight">query the user data of the attachment of an <a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a> object.  <a href="namespacecgv_1_1base.html#aec69e775624f1ca64e001ff8b1254344">More...</a><br /></td></tr>
<tr class="separator:aec69e775624f1ca64e001ff8b1254344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63edc5ab309dd943500adb7801deeb2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac63edc5ab309dd943500adb7801deeb2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ac63edc5ab309dd943500adb7801deeb2">has_property</a> (const std::string &amp;options, const std::string &amp;property, T &amp;value, bool report_error=true)</td></tr>
<tr class="memdesc:ac63edc5ab309dd943500adb7801deeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple parsing support to access values of properties in a string of property assignment  <a href="namespacecgv_1_1base.html#ac63edc5ab309dd943500adb7801deeb2">More...</a><br /></td></tr>
<tr class="separator:ac63edc5ab309dd943500adb7801deeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9306cf99f175197cf29de2b547b5cfb9"><td class="memTemplParams" colspan="2"><a id="a9306cf99f175197cf29de2b547b5cfb9"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a9306cf99f175197cf29de2b547b5cfb9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a9306cf99f175197cf29de2b547b5cfb9">find_interface</a> (<a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> start, std::vector&lt; X * &gt; &amp;result)</td></tr>
<tr class="memdesc:a9306cf99f175197cf29de2b547b5cfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">collect all nodes that implement interface X <br /></td></tr>
<tr class="separator:a9306cf99f175197cf29de2b547b5cfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bdb717a44db6f25d51ffb3a110d6aa"><td class="memTemplParams" colspan="2"><a id="a36bdb717a44db6f25d51ffb3a110d6aa"></a>
template&lt;class X , typename T &gt; </td></tr>
<tr class="memitem:a36bdb717a44db6f25d51ffb3a110d6aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a36bdb717a44db6f25d51ffb3a110d6aa">ensure_by_find</a> (X *start, T *&amp;pointer, unsigned i=0)</td></tr>
<tr class="memdesc:a36bdb717a44db6f25d51ffb3a110d6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">traverse the hierarchy to find the i-th instance of type T and set pointer to it but only in case pointer is the nullptr, returns false if pointer was nullptr and no instance of type T was found <br /></td></tr>
<tr class="separator:a36bdb717a44db6f25d51ffb3a110d6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c767fdeab1d282ea353800d967ca44"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a87c767fdeab1d282ea353800d967ca44">find_data_file</a> (const std::string &amp;file_name, const std::string &amp;strategy, const std::string &amp;sub_directory, const std::string &amp;master_path)</td></tr>
<tr class="separator:a87c767fdeab1d282ea353800d967ca44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e30b157762c186c5c0d60359e36b5c"><td class="memItemLeft" align="right" valign="top"><a id="ab6e30b157762c186c5c0d60359e36b5c"></a>
std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ab6e30b157762c186c5c0d60359e36b5c">ref_data_path_list</a> ()</td></tr>
<tr class="memdesc:ab6e30b157762c186c5c0d60359e36b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the data path list, which is constructed from the environment variable CGV_DATA <br /></td></tr>
<tr class="separator:ab6e30b157762c186c5c0d60359e36b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c98c559c9c197551a146a91a704e4b"><td class="memItemLeft" align="right" valign="top"><a id="a90c98c559c9c197551a146a91a704e4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a90c98c559c9c197551a146a91a704e4b">push_file_parent</a> (const std::string &amp;path_or_file_name)</td></tr>
<tr class="memdesc:a90c98c559c9c197551a146a91a704e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract a valid path from the given argument and push it onto the stack of parent paths. This should always be paired with a call to <a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack.">pop_file_parent()</a>. <br /></td></tr>
<tr class="separator:a90c98c559c9c197551a146a91a704e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8117654ca2eb262f18fc1093c0fdf828"><td class="memItemLeft" align="right" valign="top"><a id="a8117654ca2eb262f18fc1093c0fdf828"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828">pop_file_parent</a> ()</td></tr>
<tr class="memdesc:a8117654ca2eb262f18fc1093c0fdf828"><td class="mdescLeft">&#160;</td><td class="mdescRight">pop the latestly pushed parent path from the parent path stack. <br /></td></tr>
<tr class="separator:a8117654ca2eb262f18fc1093c0fdf828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f550111b3915df062b0bbda4795f37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aa3f550111b3915df062b0bbda4795f37">ref_parent_file_stack</a> ()</td></tr>
<tr class="memdesc:aa3f550111b3915df062b0bbda4795f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the data path list, which is constructed from the environment variable CGV_DATA  <a href="namespacecgv_1_1base.html#aa3f550111b3915df062b0bbda4795f37">More...</a><br /></td></tr>
<tr class="separator:aa3f550111b3915df062b0bbda4795f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8197d89c413eb148311cd082a5f48b5"><td class="memItemLeft" align="right" valign="top"><a id="ab8197d89c413eb148311cd082a5f48b5"></a>
FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ab8197d89c413eb148311cd082a5f48b5">open_data_file</a> (const std::string &amp;file_name, const char *mode)</td></tr>
<tr class="memdesc:ab8197d89c413eb148311cd082a5f48b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">open a file with fopen supporting resource files, that have the prefix "res://" <br /></td></tr>
<tr class="separator:ab8197d89c413eb148311cd082a5f48b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26c5e2027679d73a019e1445ca376b0"><td class="memItemLeft" align="right" valign="top"><a id="ab26c5e2027679d73a019e1445ca376b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ab26c5e2027679d73a019e1445ca376b0">read_data_file</a> (const std::string &amp;file_name, std::string &amp;content, bool ascii)</td></tr>
<tr class="memdesc:ab26c5e2027679d73a019e1445ca376b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">read ascii file into a string <br /></td></tr>
<tr class="separator:ab26c5e2027679d73a019e1445ca376b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb2083031cea3f3279d75aaac2b2419"><td class="memItemLeft" align="right" valign="top"><a id="aeeb2083031cea3f3279d75aaac2b2419"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aeeb2083031cea3f3279d75aaac2b2419">data_file_size</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:aeeb2083031cea3f3279d75aaac2b2419"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the file size of a given file with support for resource files, that have the prefix "res://" <br /></td></tr>
<tr class="separator:aeeb2083031cea3f3279d75aaac2b2419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710077a65b53cacae54e2cddbccfb5eb"><td class="memItemLeft" align="right" valign="top"><a id="a710077a65b53cacae54e2cddbccfb5eb"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a710077a65b53cacae54e2cddbccfb5eb">find_file_offset</a> (const std::string &amp;file_name, const char *data, unsigned int data_size)</td></tr>
<tr class="memdesc:a710077a65b53cacae54e2cddbccfb5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the offset of the given data block in the given file <br /></td></tr>
<tr class="separator:a710077a65b53cacae54e2cddbccfb5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e53bf7a9d7dbd6173cf988e3b2b6b92"><td class="memItemLeft" align="right" valign="top"><a id="a0e53bf7a9d7dbd6173cf988e3b2b6b92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a0e53bf7a9d7dbd6173cf988e3b2b6b92">register_object_internal</a> (<a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> object, const std::string &amp;options)</td></tr>
<tr class="memdesc:a0e53bf7a9d7dbd6173cf988e3b2b6b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an object and send event to all current registration ref_listeners() <br /></td></tr>
<tr class="separator:a0e53bf7a9d7dbd6173cf988e3b2b6b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab998d2f55de7a741cb22aba508cfe"><td class="memTemplParams" colspan="2"><a id="a1cab998d2f55de7a741cb22aba508cfe"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a1cab998d2f55de7a741cb22aba508cfe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a1cab998d2f55de7a741cb22aba508cfe">grab_focus</a> (X *instance)</td></tr>
<tr class="memdesc:a1cab998d2f55de7a741cb22aba508cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to grab the focus in the path of this node to the root of the tree <br /></td></tr>
<tr class="separator:a1cab998d2f55de7a741cb22aba508cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
resource file registration</h2></td></tr>
<tr class="memitem:a836526596df30a9ba628d7fd61aa2c76"><td class="memItemLeft" align="right" valign="top"><a id="a836526596df30a9ba628d7fd61aa2c76"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a836526596df30a9ba628d7fd61aa2c76">CommandType</a> </td></tr>
<tr class="memdesc:a836526596df30a9ba628d7fd61aa2c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumerate type for all command types supported in configuration files <br /></td></tr>
<tr class="separator:a836526596df30a9ba628d7fd61aa2c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba72200bc48e79f8a676410773a8345c"><td class="memItemLeft" align="right" valign="top"><a id="aba72200bc48e79f8a676410773a8345c"></a>
std::map&lt; std::string, <a class="el" href="structcgv_1_1base_1_1resource__file__info.html">resource_file_info</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#aba72200bc48e79f8a676410773a8345c">ref_resource_file_map</a> ()</td></tr>
<tr class="memdesc:aba72200bc48e79f8a676410773a8345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to a mapping of resource file names to resource file infos <br /></td></tr>
<tr class="separator:aba72200bc48e79f8a676410773a8345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af8d5888d85f940a5190c1f0ff9436b"><td class="memItemLeft" align="right" valign="top"><a id="a8af8d5888d85f940a5190c1f0ff9436b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a8af8d5888d85f940a5190c1f0ff9436b">register_resource_file</a> (const std::string &amp;file_path, unsigned int file_offset, unsigned int file_length, const char *file_data, const std::string &amp;source_file=&quot;&quot;)</td></tr>
<tr class="memdesc:a8af8d5888d85f940a5190c1f0ff9436b"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a resource file <br /></td></tr>
<tr class="separator:a8af8d5888d85f940a5190c1f0ff9436b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a2af3c072c02cfb161f8255dd6a94c"><td class="memItemLeft" align="right" valign="top"><a id="ad2a2af3c072c02cfb161f8255dd6a94c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#ad2a2af3c072c02cfb161f8255dd6a94c">register_resource_string</a> (const std::string &amp;string_name, const char *string_data)</td></tr>
<tr class="memdesc:ad2a2af3c072c02cfb161f8255dd6a94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a resource string <br /></td></tr>
<tr class="separator:ad2a2af3c072c02cfb161f8255dd6a94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c6f4c42602d5fdda61e603f5cbe25e"><td class="memItemLeft" align="right" valign="top"><a id="a78c6f4c42602d5fdda61e603f5cbe25e"></a>
<a class="el" href="namespacecgv_1_1base.html#a836526596df30a9ba628d7fd61aa2c76">CommandType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a78c6f4c42602d5fdda61e603f5cbe25e">analyze_command</a> (const <a class="el" href="structcgv_1_1utils_1_1token.html">cgv::utils::token</a> &amp;cmd, bool eliminate_quotes=true, <a class="el" href="structcgv_1_1base_1_1command__info.html">command_info</a> *info_ptr=0)</td></tr>
<tr class="memdesc:a78c6f4c42602d5fdda61e603f5cbe25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a command and optionally store result in the command info, returns the command type <br /></td></tr>
<tr class="separator:a78c6f4c42602d5fdda61e603f5cbe25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db812e195f6d3578be37667b1370ff5"><td class="memItemLeft" align="right" valign="top"><a id="a3db812e195f6d3578be37667b1370ff5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecgv_1_1base.html#a3db812e195f6d3578be37667b1370ff5">process_command</a> (const <a class="el" href="structcgv_1_1base_1_1command__info.html">command_info</a> &amp;info)</td></tr>
<tr class="memdesc:a3db812e195f6d3578be37667b1370ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">process a command given by a command info structure, return whether command was processed correctly <br /></td></tr>
<tr class="separator:a3db812e195f6d3578be37667b1370ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>the base namespace holds the base hierarchy, support for plugin registration and signals </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a746925f26d076c26742b2dc558cbae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746925f26d076c26742b2dc558cbae36">&#9670;&nbsp;</a></span>TraversePolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecgv_1_1base.html#a746925f26d076c26742b2dc558cbae36">cgv::base::TraversePolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>different traversal policies </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a4dd87fc30d8a2e369fe315eb9ccde557"></a>TP_ONLY_FOCUS&#160;</td><td class="fielddoc"><p>traverse all children </p>
</td></tr>
<tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a69ee76315433dc44f8bfa441afefa249"></a>TP_FIRST_FOCUS&#160;</td><td class="fielddoc"><p>traverse only the focused child </p>
</td></tr>
<tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a169ba2fab3a13ea551eb8d8800e459bb"></a>TP_AUTO_FOCUS&#160;</td><td class="fielddoc"><p>first traverse focused and then the remaining children </p>
</td></tr>
<tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a7b2b5c718b50e4241491dcb951599a8b"></a>TP_STOP_ON_SUCCESS&#160;</td><td class="fielddoc"><p>like previous but change focus to the child, where traversal succeeded </p>
</td></tr>
<tr><td class="fieldname"><a id="a746925f26d076c26742b2dc558cbae36a33806b12ea827401e0a110036ddbeabe"></a>TP_STOP_ON_FAILURE&#160;</td><td class="fielddoc"><p>this is an optional flag for traversals with methods that return a bool. If the returned bool is true, traversal stops if this flag is set </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac56137cd8bf24c23f7f6ef15a417bbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56137cd8bf24c23f7f6ef15a417bbdd">&#9670;&nbsp;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API bool cgv::base::attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td>
          <td class="paramname"><em>slot_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td>
          <td class="paramname"><em>attachment_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to attach an object to an object of type <a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a>. </p>
<p>Return whether the slot_object implements the <a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a> interface and could retreive the attachment. </p>

</div>
</div>
<a id="ada908977e738c6da6230a698912bebc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada908977e738c6da6230a698912bebc4">&#9670;&nbsp;</a></span>define_registration_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::define_registration_order </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>partial_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>before_contructor_execution</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>when</em> = <code>&quot;always&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specify a partial order of objects for registration </p>
<p><code>partial_order</code> is a semicolon separated list of type names that can ignore name spaces. <code>before_constructor_execution</code> tells whether the reordering should happen before constructors of delayed registration events are called. <code>when</code> specifies in which call to <code>enable_registration</code> the reordering should happen. Possible values are</p><ul>
<li>"always"</li>
<li>"program" only once for the enable event of the executed program</li>
<li>"plugins" for enable events of all loaded plugins</li>
<li>&lt;plugin_name&gt; only for the enable event of the plugin with the given name If several partial orders are defined for an enable call, a combined partial order is computed and used to find the order closest to the actual registration order that is in accordance to the combined partial order. </li>
</ul>

</div>
</div>
<a id="aa839bf46a9e8abb32cfea4964ec91507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa839bf46a9e8abb32cfea4964ec91507">&#9670;&nbsp;</a></span>enable_registration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::enable_registration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enable registration and send all registration events that where emitted during disabled registration </p>
<p>Enable registration (default is that registration is disabled).</p>
<p>If registration has been disabled before, send all registration events that where emitted during disabled registration. </p>

</div>
</div>
<a id="a5972c6c1a1833e46393f9361ea2b860a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5972c6c1a1833e46393f9361ea2b860a">&#9670;&nbsp;</a></span>enable_registration_event_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::enable_registration_event_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable cleanup of registration events (default). </p>
<p>If registration event cleanup is disabled, registration events are not discarded as soon as objects have been registered. This makes objects available to listeners that are registered later. </p>

</div>
</div>
<a id="a87c767fdeab1d282ea353800d967ca44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c767fdeab1d282ea353800d967ca44">&#9670;&nbsp;</a></span>find_data_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API std::string cgv::base::find_data_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sub_directory</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>master_path</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a file with the given strategy and return the file name extended by the necessary path. The strategy defines in which search paths the file should be looked for, whether the search paths should be searched recursively and in which order the search paths should be searched (see details below). Optional arguments are a sub_directory and a master_path. For all non recursive searches the sub_directory will be added to each search path and the file is first looked up in the sub_directory. The master_path just defines another search path that can be used by the search strategy.</p>
<p>The search strategy is a string containing one letter for each search command, which are processed in the order of the string. Each capital letter causes a recursive search. The following search commands are available:</p><ul>
<li>r/R ... search resource files (no recursive search necessary as resource files do not have paths) and if found add the prefix "res://" to the file_name</li>
<li>c/C ... search current directory (here no path prefix is used)</li>
<li>m/M ... search master path</li>
<li>d/D ... search all data paths registered in the environment variable CGV_DATA</li>
<li>p/P ... search the path of the parent on the parent path stack that is controlled with <a class="el" href="namespacecgv_1_1base.html#a90c98c559c9c197551a146a91a704e4b" title="extract a valid path from the given argument and push it onto the stack of parent paths....">push_file_parent()</a> and <a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack.">pop_file_parent()</a></li>
<li>a/A ... search all anchester paths of the all parents on the parent path stack that is controlled with <a class="el" href="namespacecgv_1_1base.html#a90c98c559c9c197551a146a91a704e4b" title="extract a valid path from the given argument and push it onto the stack of parent paths....">push_file_parent()</a> and <a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack.">pop_file_parent()</a> As an example the strategy "cpmD" first looks in the current directory, then in the parent directory, then in the master path and finally recursively in each of the registered data paths. </li>
</ul>

</div>
</div>
<a id="a1e3f23268db7fec467dfd98ab36094f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3f23268db7fec467dfd98ab36094f5">&#9670;&nbsp;</a></span>get_attachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API <a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a> cgv::base::get_attachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td>
          <td class="paramname"><em>slot_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>query the attachment of an <a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a> object. </p>
<p>If the slot_object is not derived from the <a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a> interface, return an empty base_ptr. </p>

</div>
</div>
<a id="aec69e775624f1ca64e001ff8b1254344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec69e775624f1ca64e001ff8b1254344">&#9670;&nbsp;</a></span>get_attachment_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void * cgv::base::get_attachment_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td>
          <td class="paramname"><em>slot_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>query the user data of the attachment of an <a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a> object. </p>
<p>If the slot_object is not derived from the <a class="el" href="classcgv_1_1base_1_1attach__slot.html">attach_slot</a> interface, return the null pointer. </p>

</div>
</div>
<a id="ac63edc5ab309dd943500adb7801deeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63edc5ab309dd943500adb7801deeb2">&#9670;&nbsp;</a></span>has_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cgv::base::has_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report_error</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simple parsing support to access values of properties in a string of property assignment </p>
<p>Given an option string (first parameter) with name-value-pairs, i.e. "x=10.4;tooltip='help'" and a property name (second parameter), the function returns whether the option string contains an assignment of the queried property and if yes, the value is stored in the reference given in the third parameter. The type casts supported by the <a class="el" href="structcgv_1_1type_1_1variant.html">cgv::type::variant</a> type are used when converting to the reference type.</p>
<p>Examples:</p>
<p>true == has_property("x=10.4;tooltip='help'", "x", dbl_var)"       ==&gt; dbl_var = 10.4
    true  == has_property("x=10.4;tooltip='help'", "x", str_var)" ==&gt; str_var = "10.4" true == has_property("x=10.4;tooltip='help'", "tooltip", str_var)" ==&gt; str_var = "help"
    false == has_property("x=10.4;tooltip='help'", "y", int_var)" ==&gt; int_var ... not changed </p>

</div>
</div>
<a id="acf58539e451af7248fa0d2e64bbb48f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf58539e451af7248fa0d2e64bbb48f5">&#9670;&nbsp;</a></span>load_plugin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void * cgv::base::load_plugin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load a plugin or dll and return a handle to the plugin, or 0 if loading was not successful. </p>
<p>During plugin loading the registration is always disabled in order to avoid deadlocks that can arise when a registered object triggers loading of another dll. </p>

</div>
</div>
<a id="a5e0e3861c731016fa00726b7e17eadd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0e3861c731016fa00726b7e17eadd1">&#9670;&nbsp;</a></span>process_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CGV_API cgv::base::process_command </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eliminate_quotes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>process a command given as string. </p>
<p>Return whether the command was processed correctly. If eliminate_quotes is set to true, quotes around the command arguments are eliminated. This feature is used for commands specified on the command line, where spaces in the command arguments would split one command into pieces. Quotes are used then to protect the command from splitting.</p>
<p>The following commands are supported:</p><ul>
<li>show all ... print out information on all registered objects</li>
<li>plugin:file_name ... read a plugin</li>
<li>config:file_name ... read a config file</li>
<li>gui:file_name ... read a gui description file</li>
<li>name(xxx):assignment list ... find registered object by name xxx and process assignments on them</li>
<li>type(yyy):assignment list ... find registered object by type yyy and process assignments on them</li>
</ul>
<p>The assigment list in the name and type commands are of the form:</p>
<p>member_name_1=value_1;member_name_2=value_2;... </p>

</div>
</div>
<a id="aa3f550111b3915df062b0bbda4795f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f550111b3915df062b0bbda4795f37">&#9670;&nbsp;</a></span>ref_parent_file_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API std::vector&lt; std::string &gt; &amp; cgv::base::ref_parent_file_stack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a reference to the data path list, which is constructed from the environment variable CGV_DATA </p>
<p>return a reference to the parent file stack controlled with <a class="el" href="namespacecgv_1_1base.html#a90c98c559c9c197551a146a91a704e4b" title="extract a valid path from the given argument and push it onto the stack of parent paths....">push_file_parent()</a> and <a class="el" href="namespacecgv_1_1base.html#a8117654ca2eb262f18fc1093c0fdf828" title="pop the latestly pushed parent path from the parent path stack.">pop_file_parent()</a>, where the last vector element is the latestly pushed one </p>

</div>
</div>
<a id="ad3783da9c295a7c532f2ea35d2a06abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3783da9c295a7c532f2ea35d2a06abb">&#9670;&nbsp;</a></span>register_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::register_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register an object and send event to all current registration ref_listeners() </p>
<p>register an object.</p>
<p>This will send an event to all currently registered registration listeners. The options parameter can be used to select a specific listener. </p>

</div>
</div>
<a id="a9e4204680cce6ce77447fcab18a7fab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4204680cce6ce77447fcab18a7fab0">&#9670;&nbsp;</a></span>register_prog_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGV_API void cgv::base::register_prog_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prog_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the file name of the current program. </p>
<p>simply pass argv[0] in the main procedure. This is done automatically in the process_command_line_args function. </p>

</div>
</div>
<a id="aa6cfc52fcd0ab300675162f464038e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cfc52fcd0ab300675162f464038e45">&#9670;&nbsp;</a></span>unregister_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGV_API cgv::base::unregister_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecgv_1_1base.html#adf49b672c57e35e9ac4a9d6980f50562">base_ptr</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unregister an object and send event to all current registration ref_listeners() </p>
<p>unregister an object and send event to all currently registered registration listeners </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecgv.html">cgv</a></li><li class="navelem"><a class="el" href="namespacecgv_1_1base.html">base</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
